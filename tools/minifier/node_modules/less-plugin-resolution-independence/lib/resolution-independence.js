// Adding a "plugin" that works with LESS 1.7, for converting pixel measurements to resolution
// independent units i.e. rems.
;(function(){

    var less;
    if (typeof window != 'undefined') {
        less = window.less || {};
    } else {
        less = require("less");
    }

    var ResolutionIndependence = function(opts) {
        this._baseSize = opts && opts.baseSize || this._baseSize;
        this._riUnit = opts && opts.riUnit || this._riUnit;
        this._unit = opts && opts.unit || this._unit;
    };
    ResolutionIndependence.prototype = {
        _baseSize: 12,
        _riUnit: 'rem',
        _unit: 'px',
        _ignoreUnit: 'apx', // "absolute" px
        run: function (root) {
			this._visitor = this._visitor || new less.tree.visitor(this);
            return this._visitor.visit(root);
        },
        visitRule: function (node) {
            var valueNode = node && !node.inline && node.value && node.value.value && node.value.value.length && node.value.value[0],
                stringValues,
                convertedStringValues,
                i;

            if (Array.isArray(valueNode.args)) {
                for (i = 0; i < valueNode.args.length; i++) {
                    this.convertValue(valueNode.args[i]);
                }
            } else if (Array.isArray(valueNode.value)) {
                for (i = 0; i < valueNode.value.length; i++) {
                    this.convertValue(valueNode.value[i]);
                }
            } else if (typeof valueNode.value == 'string' && valueNode.value.match(/\d+/g)) {
                stringValues = valueNode.value.match(/\S+/g) || [];
                convertedStringValues = stringValues.map(this.parseValue.bind(this));
                valueNode.value = convertedStringValues.join(' ');
            } else {
                this.convertValue(valueNode);
            }

            return node;
        },
        convertValue: function (valueNode) {
            var value = valueNode.value,
                unit = valueNode.unit,
                result;

            result = this.parseValue(value, unit);

            if (unit && result && typeof result == 'object') {
                valueNode.value = result.value;
                valueNode.unit.numerator[0] = result.unit;
            } else if (result) {
                valueNode.value = result;
            }
        },
        parseValue: function (value, unit) {
            if (value && value.toString().slice(-1*this._ignoreUnit.length) == this._ignoreUnit) {
                return parseInt(value, 10) + this._unit;
            } else if (value && value.toString().slice(-1*this._unit.length) == this._unit) {
                return parseInt(value, 10) / this._baseSize + this._riUnit;
            } else if (unit && unit.numerator && unit.numerator.length && unit.numerator[0] == this._unit) {
                return {
                    value: value / this._baseSize,
                    unit: this._riUnit
                };
            }

            return value;
        }
    };

    if (typeof window != 'undefined') {
		window.enyoLessRiPlugin = ResolutionIndependence;
    } else {
        module.exports = ResolutionIndependence;
    }

}());